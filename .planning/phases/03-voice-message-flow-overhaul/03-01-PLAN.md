---
phase: 03-voice-message-flow-overhaul
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - User taps mic → sees "listening" state with visual feedback
    - User taps again → recording stops, thread opens
    - Voice message shows processing state
    - Transcribed message appears in thread
    - AI response appears after transcription
  artifacts:
    - path: "app/page.tsx"
      provides: "Voice recording state management"
      exports: ["handlePushToTalk", "sendAudioToN8n"]
      min_lines: 100
  key_links:
    - from: "app/page.tsx:handlePushToTalk"
      to: "MediaRecorder API"
      via: "getUserMedia and MediaRecorder setup"
      pattern: "navigator\\.mediaDevices\\.getUserMedia"
    - from: "app/page.tsx:sendAudioToN8n"
      to: "/api/voice"
      via: "FormData upload with user_id and thread_id"
      pattern: "fetch.*\\/api\\/voice"
    - from: "app/page.tsx:messages state"
      to: "Supabase real-time subscription"
      via: "SubscribeToConversations callback"
      pattern: "SubscribeToConversations"
---

<objective>
Fix voice recording state management and thread handling

Purpose: Eliminate UI flickering and missing messages during voice message flow
Output: Stable voice recording with predictable thread behavior
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@CLAUDE.md
@app/page.tsx
@app/api/voice/route.ts
</context>

<tasks>

<task type="auto">
  <name>Fix voice recording state machine</name>
  <files>app/page.tsx</files>
  <action>
Fix the voice recording state transitions to prevent race conditions and flickering:

1. **Consolidate state flags** (lines 367, 401, 445):
   - `isRecording` - true when MediaRecorder is active
   - `isProcessing` - true from recording stop until AI response arrives
   - Remove redundant `isPushToTalk` flag - use `isRecording` directly

2. **Fix thread creation timing** (lines 1857-1872):
   - Move thread creation BEFORE recording starts (not in stop handler)
   - Set currentThreadId when user first taps mic
   - Update URL immediately: `window.history.pushState({}, "", "/")`
   - This prevents "no thread" errors during audio upload

3. **Prevent double state updates** (lines 1848-1853):
   - Remove duplicate `setIsRecording(false)` calls (appears twice)
   - Use single state update block in stop handler

4. **Clear temp messages properly** (lines 1887-1894, 1943-1954):
   - Replace temp message logic with consistent loading state
   - Remove "temp-loading-msg" and "temp-voice-processing" separate logic
   - Use single "Processing voice..." message with id "temp-voice"
   - Clear only this specific temp message when real messages arrive

5. **Fix orb animation state** (lines 1838-1839, 1853):
   - Set `setOrbAnimating(true)` only when recording starts
   - Set `setOrbAnimating(false)` when recording stops
   - Keep animation active during processing until transcription arrives
  </action>
  <verify>
Read app/page.tsx and verify:
- isPushToTalk flag removed, replaced with isRecording
- Thread creation happens before recording starts
- No duplicate setIsRecording calls exist
- Single temp message pattern with id "temp-voice"
- Orb animation state matches recording state
  </verify>
  <done>
Voice recording state transitions are clean:
- Start: Create thread → Start recording → Set isRecording=true
- Stop: Stop recording → Set isRecording=false → Set isProcessing=true → Upload audio
- Complete: Clear temp messages → Display real messages → Set isProcessing=false
  </done>
</task>

<task type="auto">
  <name>Fix polling and real-time subscription conflicts</name>
  <files>app/page.tsx</files>
  <action>
Fix the dual update mechanism (polling + real-time) causing message duplication:

1. **Remove polling from sendAudioToN8n** (lines 1985-2003):
   - Delete the `setInterval` polling loop entirely
   - Remove `__voicePollTimer` global variable hack
   - Trust Supabase real-time subscription to deliver messages
   - Keep only 202 status handling without polling

2. **Update real-time subscription handler** (lines 935-964):
   - When new assistant message arrives, clear loading states immediately:
     ```typescript
     setLoading(false)
     setIsProcessing(false)
     ```
   - Remove temp messages: `setMessages(prev => prev.filter(m => !m.id.startsWith("temp-")))`
   - This prevents showing both temp and real messages simultaneously

3. **Add timeout fallback** (replace polling):
   - After 30 seconds, if no real-time message arrives:
     ```typescript
     setTimeout(() => {
       if (isProcessing) {
         loadConversations(activeThreadId)
         setLoading(false)
         setIsProcessing(false)
       }
     }, 30000)
     ```
   - This handles cases where real-time subscription fails

4. **Handle 202 response cleanly** (lines 1962-2007):
   - On 202: Set loading state, add temp message, return immediately
   - Don't call loadConversations or loadThreads synchronously
   - Let real-time subscription handle updates
  </action>
  <verify>
Read app/page.tsx sendAudioToN8n function and verify:
- No setInterval polling exists
- Real-time subscription handler clears loading states
- 30-second timeout fallback exists
- No synchronous loadConversations after 202 response
  </verify>
  <done>
Voice message updates arrive via:
- Primary path: Supabase real-time subscription (instant)
- Fallback path: 30s timeout → manual fetch
- No polling intervals
- No message duplication
  </done>
</task>

<task type="auto">
  <name>Fix thread loading and message persistence</name>
  <files>app/page.tsx</files>
  <action>
Ensure thread list and messages load correctly after voice message:

1. **Reload threads AFTER real-time message arrives** (not during upload):
   - Move `loadThreads()` call from sendAudioToN8n to real-time subscription handler
   - When assistant message received via subscription:
     ```typescript
     setMessages(prev => [...prev.filter(m => !m.id.startsWith("temp-")), newMessage])
     setLoading(false)
     setIsProcessing(false)
     loadThreads() // Update sidebar thread list
     ```

2. **Update thread title from transcription**:
   - When first user message arrives (transcribed voice), update thread title
   - In real-time subscription, check if message is user role + thread title is "Voice Chat"
   - If so, update: `updateThreadTitle(threadId, firstWords)`
   - Use first 50 chars of transcribed message

3. **Fix messages.length === 0 condition** (lines 1877-1894):
   - Condition `activeModule === "home" && messages.length === 0` shows Orb
   - After recording stops, messages array has temp message, so this works
   - Verify messages array is never cleared during voice flow

4. **Persist thread_id in URL**:
   - After thread creation, update URL: `window.history.pushState({}, "", "/")`
   - After recording complete, verify thread_id persists in URL
   - Check loadConversations receives correct thread_id from state

5. **Handle "no thread" edge case**:
   - If sendAudioToN8n somehow runs without thread_id:
   - Create thread synchronously before upload
   - Log warning: "Voice message sent without thread - creating one"
  </action>
  <verify>
Test the flow:
1. Tap mic (first time, no thread exists)
2. Tap again to stop
3. Check: Thread appears in sidebar
4. Check: Transcribed message appears
5. Check: AI response appears
6. Navigate away and back - messages persist
  </verify>
  <done>
Thread handling works correctly:
- Thread created before upload starts
- Thread appears in sidebar after voice message
- Messages persist across navigation
- Thread title updates with transcription
  </done>
</task>

</tasks>

<verification>
Manual test flow:
1. Open app (home screen, no existing threads)
2. Tap microphone → Orb shows "listening" animation
3. Speak a message
4. Tap microphone again → Recording stops
5. Observe: Thread opens immediately with "Processing voice..." message
6. Wait for transcription
7. Observe: User message appears with transcribed text
8. Wait for AI response
9. Observe: AI response appears below
10. Refresh page → Messages persist
11. Check sidebar → Thread exists with correct title
12. Repeat with existing thread → No new thread created
</verification>

<success_criteria>
Voice message flow works end-to-end:
- ✅ Tap mic → "listening" state visible
- ✅ Tap again → Recording stops, thread opens immediately
- ✅ Processing state shows while waiting
- ✅ Transcribed message appears in thread
- ✅ AI response appears after transcription
- ✅ Thread persists in sidebar
- ✅ Messages persist across refresh
- ✅ No UI flickering during transitions
- ✅ No duplicate messages
- ✅ No "thread not found" errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-message-flow-overhaul/03-01-SUMMARY.md`
</output>
