---
phase: 03-voice-message-flow-overhaul
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - app/page.tsx
autonomous: false

must_haves:
  truths:
    - Recording shows pulsing animation
    - Processing shows skeleton loader
    - Thread opens immediately (no delay)
    - Messages render without flicker
    - Smooth transitions between states
  artifacts:
    - path: "app/page.tsx"
      provides: "Visual feedback for voice states"
      contains: "orb.*animate"
  key_links:
    - from: "app/page.tsx:isRecording state"
      to: "Orb animation CSS"
      via: "className conditional rendering"
      pattern: "isRecording.*orb"
---

<objective>
Polish UI/UX for voice message flow with smooth transitions and clear visual feedback

Purpose: Eliminate UI flickering and provide clear visual feedback at every stage
Output: Professional, smooth voice recording experience
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@CLAUDE.md
@app/page.tsx
@.planning/phases/03-voice-message-flow-overhaul/03-01-SUMMARY.md
@.planning/phases/03-voice-message-flow-overhaul/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add visual state indicators</name>
  <files>app/page.tsx</files>
  <action>
Improve visual feedback for each voice message state:

1. **Recording state** (Orb with pulsing animation):
   - Find orb rendering code (search for "Orb" component or orb-related div)
   - Add pulsing red ring when `isRecording` is true:
     ```typescript
     {isRecording && (
       <div className="absolute inset-0 rounded-full border-4 border-red-500 animate-ping opacity-75" />
     )}
     ```
   - Change orb color to red during recording: `bg-red-500` instead of default
   - Add microphone icon inside orb when recording

2. **Processing state** (Skeleton loader):
   - When temp message with id "temp-voice" is shown:
   - Replace plain text with skeleton loader animation:
     ```typescript
     {message.id.startsWith("temp-") ? (
       <div className="space-y-2 animate-pulse">
         <div className="h-4 bg-white/20 rounded w-3/4"></div>
         <div className="h-4 bg-white/20 rounded w-1/2"></div>
       </div>
     ) : (
       renderMessageContent(message.content)
     )}
     ```

3. **Transition states**:
   - Add fade-in animation for new messages appearing:
     ```typescript
     <div className="animate-fade-in">
       {/* message content */}
     </div>
     ```
   - Add to Tailwind config or use existing animation utilities

4. **Microphone button states**:
   - Idle: Gray microphone icon
   - Recording: Red pulsing microphone icon with "Recording..." tooltip
   - Processing: Disabled state with spinner icon
   - Update button visual based on `isRecording` and `isProcessing`:
     ```typescript
     <button
       onClick={handlePushToTalk}
       disabled={isProcessing && !isRecording}
       className={cn(
         "p-3 rounded-full transition-all",
         isRecording ? "bg-red-500 animate-pulse" : "bg-[#2A2826]",
         isProcessing && !isRecording && "opacity-50 cursor-not-allowed"
       )}
     >
       {isRecording ? (
         <Mic className="w-5 h-5 text-white" />
       ) : isProcessing ? (
         <Loader2 className="w-5 h-5 text-white/60 animate-spin" />
       ) : (
         <Mic className="w-5 h-5 text-white/60" />
       )}
     </button>
     ```

5. **Sound effects** (optional enhancement):
   - Play "start" sound when recording begins
   - Play "sent" sound when recording stops
   - Use HTML5 Audio API:
     ```typescript
     const playSound = (type: 'start' | 'sent') => {
       const audio = new Audio(`/sounds/${type}.mp3`)
       audio.play().catch(e => console.log('Sound play failed:', e))
     }
     ```
  </action>
  <verify>
Test visual states:
1. Tap mic → Orb shows red pulsing ring
2. Tap again → Button shows spinner
3. Processing → Skeleton loader animates
4. Message arrives → Fades in smoothly
5. All transitions are smooth, no flicker
  </verify>
  <done>
Visual feedback is clear at every stage:
- Recording: Red pulsing orb/button
- Processing: Skeleton loader animation
- New messages: Fade-in effect
- Button disabled during processing
- Optional: Sound effects for start/stop
  </done>
</task>

<task type="auto">
  <name>Optimize message rendering performance</name>
  <files>app/page.tsx</files>
  <action>
Prevent message list flicker and optimize rendering:

1. **Memoize message components**:
   - Add React.memo to prevent unnecessary re-renders
   - Extract message rendering to separate component:
     ```typescript
     const MessageBubble = React.memo(({ message }: { message: Message }) => (
       <div className={cn("message-bubble", message.role === "user" ? "user" : "assistant")}>
         {renderMessageContent(message.content)}
       </div>
     ))
     ```

2. **Use message.id as key** (not index):
   - In messages.map(), verify key={message.id}
   - This prevents React from re-rendering all messages when array changes

3. **Batch state updates**:
   - When adding temp message + setting loading state, use single update:
     ```typescript
     // Instead of:
     setMessages(prev => [...prev, tempMsg])
     setLoading(true)
     setIsProcessing(true)
     
     // Use:
     startTransition(() => {
       setMessages(prev => [...prev, tempMsg])
       setLoading(true)
       setIsProcessing(true)
     })
     ```

4. **Debounce scroll-to-bottom**:
   - Messages update rapidly during real-time subscription
   - Debounce scroll to prevent jank:
     ```typescript
     const scrollToBottomDebounced = useMemo(
       () => debounce(() => {
         messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })
       }, 100),
       []
     )
     ```

5. **Lazy load message list**:
   - If thread has >50 messages, use virtual scrolling
   - For now, just ensure smooth rendering of <50 messages
   - Add `will-change: transform` to message container for GPU acceleration
  </action>
  <verify>
Performance check:
1. Record 5 voice messages in quick succession
2. Observe: No flicker when messages appear
3. Observe: Smooth scrolling to bottom
4. Check DevTools: No excessive re-renders
5. Check: Messages render in <16ms (60fps)
  </verify>
  <done>
Message rendering is optimized:
- Message components memoized
- Correct key usage (message.id)
- Batched state updates
- Debounced scroll
- Smooth 60fps rendering
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete voice message flow with:
- Clean state transitions (no race conditions)
- Automatic retry on network errors
- Comprehensive error messages
- Smooth visual feedback
- Optimized rendering
  </what-built>
  <how-to-verify>
**Test Scenarios:**

1. **Happy path - First voice message**:
   - Open fresh app (no threads)
   - Tap microphone → Observe red pulsing orb
   - Speak: "Create a task to review quarterly financials"
   - Tap microphone again → Observe thread opens immediately
   - Wait for processing (skeleton loader visible)
   - Verify: Transcribed message appears
   - Verify: AI response appears
   - Verify: Thread shows in sidebar with title
   - Refresh page → Messages persist

2. **Happy path - Existing thread**:
   - With thread from test 1 open
   - Send another voice message
   - Verify: No new thread created
   - Verify: Message added to same thread

3. **Error recovery**:
   - Disable network
   - Send voice message
   - Observe: 3 retry attempts with status messages
   - Observe: Error message appears
   - Re-enable network
   - Send new voice message
   - Verify: Error clears, new message works

4. **Permission denied**:
   - Block microphone permission in browser
   - Tap microphone
   - Verify: Permission error message appears
   - Re-enable permission
   - Tap microphone again
   - Verify: Recording works

5. **Rapid recording**:
   - Send 3 voice messages rapidly (one after another)
   - Verify: All three process correctly
   - Verify: No UI flicker or crashes
   - Verify: Messages appear in correct order

6. **Timeout scenario** (optional - takes 60s):
   - Send voice message
   - Wait 60 seconds without response
   - Verify: Timeout message appears
   - Verify: App recovers gracefully

**Expected Results:**
- ✅ All scenarios work without crashes
- ✅ UI transitions are smooth (no flicker)
- ✅ Error messages are clear and helpful
- ✅ Thread persistence works correctly
- ✅ Visual feedback is clear at every stage

**If issues found:**
Type "issues:" followed by description of what's broken
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
Final integration test checklist:
- [ ] First voice message creates thread
- [ ] Subsequent messages use same thread
- [ ] Thread appears in sidebar
- [ ] Thread title updates from transcription
- [ ] Messages persist after refresh
- [ ] Network errors retry automatically
- [ ] Permission errors show helpful message
- [ ] Processing timeout works (60s)
- [ ] Visual states are clear (recording/processing)
- [ ] No UI flicker during transitions
- [ ] Rapid voice messages work correctly
- [ ] Error recovery works (dismiss error, try again)
</verification>

<success_criteria>
Voice message flow is production-ready:
- ✅ Zero UI flickering
- ✅ Zero missing messages
- ✅ Zero transmission errors
- ✅ Threads load correctly after voice/text messages
- ✅ Clear visual feedback at all stages
- ✅ Automatic error recovery
- ✅ Helpful error messages
- ✅ Smooth transitions
- ✅ 60fps rendering
- ✅ Professional UX
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-message-flow-overhaul/03-03-SUMMARY.md`
</output>
